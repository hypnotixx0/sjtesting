<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Purge Proxy - Scramjet Style</title>
    <link rel="stylesheet" href="style.css">
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üöÄ</text></svg>">
    
    <!-- Scramjet dependencies -->
    <script src="/scram/scramjet.all.js" defer></script>
    <script src="/scram/scramjet.sync.js" defer></script>
    
    <!-- BareMux library -->
    <script>
        // Embed BareMux directly from your code
        !function(e, t) {
            "object" == typeof exports && "undefined" != typeof module ? t(exports) : "function" == typeof define && define.amd ? define(["exports"], t) : t((e = "undefined" != typeof globalThis ? globalThis : e || self).BareMux = {})
        }(this, (function(e) {
            "use strict";
            const t = globalThis.fetch
              , r = globalThis.SharedWorker
              , a = globalThis.localStorage
              , o = globalThis.navigator.serviceWorker
              , s = MessagePort.prototype.postMessage
              , n = {
                prototype: {
                    send: WebSocket.prototype.send
                },
                CLOSED: WebSocket.CLOSED,
                CLOSING: WebSocket.CLOSING,
                CONNECTING: WebSocket.CONNECTING,
                OPEN: WebSocket.OPEN
            };
            async function c() {
                const e = (await self.clients.matchAll({
                    type: "window",
                    includeUncontrolled: !0
                })).map((async e => {
                    const t = await function(e) {
                        let t = new MessageChannel;
                        return new Promise((r => {
                            e.postMessage({
                                type: "getPort",
                                port: t.port2
                            }, [t.port2]),
                            t.port1.onmessage = e => {
                                r(e.data)
                            }
                        }
                        ))
                    }(e);
                    return await i(t),
                    t
                }
                ))
                  , t = Promise.race([Promise.any(e), new Promise(( (e, t) => setTimeout(t, 1e3, new TypeError("timeout"))))]);
                try {
                    return await t
                } catch (e) {
                    if (e instanceof AggregateError)
                        throw console.error("bare-mux: failed to get a bare-mux SharedWorker MessagePort as all clients returned an invalid MessagePort."),
                        new Error("All clients returned an invalid MessagePort.");
                    return console.warn("bare-mux: failed to get a bare-mux SharedWorker MessagePort within 1s, retrying"),
                    await c()
                }
            }
            function i(e) {
                const t = new MessageChannel
                  , r = new Promise(( (e, r) => {
                    t.port1.onmessage = t => {
                        "pong" === t.data.type && e()
                    }
                    ,
                    setTimeout(r, 1500)
                }
                ));
                return s.call(e, {
                    message: {
                        type: "ping"
                    },
                    port: t.port2
                }, [t.port2]),
                r
            }
            function l(e, t) {
                const a = new r(e,"bare-mux-worker");
                return t && o.addEventListener("message", (t => {
                    if ("getPort" === t.data.type && t.data.port) {
                        console.debug("bare-mux: recieved request for port from sw");
                        const a = new r(e,"bare-mux-worker");
                        s.call(t.data.port, a.port, [a.port])
                    }
                }
                )),
                a.port
            }
            let h = null;
            function d() {
                if (null === h) {
                    const e = new MessageChannel
                      , t = new ReadableStream;
                    let r;
                    try {
                        s.call(e.port1, t, [t]),
                        r = !0
                    } catch (e) {
                        r = !1
                    }
                    return h = r,
                    r
                }
                return h
            }
            class p {
                constructor(e) {
                    this.channel = new BroadcastChannel("bare-mux"),
                    e instanceof MessagePort || e instanceof Promise ? this.port = e : this.createChannel(e, !0)
                }
                createChannel(e, t) {
                    if (self.clients)
                        this.port = c(),
                        this.channel.onmessage = e => {
                            "refreshPort" === e.data.type && (this.port = c())
                        }
                        ;
                    else if (e && SharedWorker) {
                        if (!e.startsWith("/") && !e.includes("://"))
                            throw new Error("Invalid URL. Must be absolute or start at the root.");
                        this.port = l(e, t),
                        console.debug("bare-mux: setting localStorage bare-mux-path to", e),
                        a["bare-mux-path"] = e
                    } else {
                        if (!SharedWorker)
                            throw new Error("Unable to get a channel to the SharedWorker.");
                        {
                            const e = a["bare-mux-path"];
                            if (console.debug("bare-mux: got localStorage bare-mux-path:", e),
                            !e)
                                throw new Error("Unable to get bare-mux workerPath from localStorage.");
                            this.port = l(e, t)
                        }
                    }
                }
                async sendMessage(e, t) {
                    this.port instanceof Promise && (this.port = await this.port);
                    try {
                        await i(this.port)
                    } catch {
                        return console.warn("bare-mux: Failed to get a ping response from the worker within 1.5s. Assuming port is dead."),
                        this.createChannel(),
                        await this.sendMessage(e, t)
                    }
                    const r = new MessageChannel
                      , a = [r.port2, ...t || []]
                      , o = new Promise(( (e, t) => {
                        r.port1.onmessage = r => {
                            const a = r.data;
                            "error" === a.type ? t(a.error) : e(a)
                        }
                    }
                    ));
                    return s.call(this.port, {
                        message: e,
                        port: r.port2
                    }, a),
                    await o
                }
            }
            class u extends EventTarget {
                constructor(e, t=[], r, a) {
                    super(),
                    this.protocols = t,
                    this.readyState = n.CONNECTING,
                    this.url = e.toString(),
                    this.protocols = t;
                    const o = e => {
                        this.protocols = e,
                        this.readyState = n.OPEN;
                        const t = new Event("open");
                        this.dispatchEvent(t)
                    }
                      , s = async e => {
                        const t = new MessageEvent("message",{
                            data: e
                        });
                        this.dispatchEvent(t)
                    }
                      , c = (e, t) => {
                        this.readyState = n.CLOSED;
                        const r = new CloseEvent("close",{
                            code: e,
                            reason: t
                        });
                        this.dispatchEvent(r)
                    }
                      , i = () => {
                        this.readyState = n.CLOSED;
                        const e = new Event("error");
                        this.dispatchEvent(e)
                    }
                    ;
                    this.channel = new MessageChannel,
                    this.channel.port1.onmessage = e => {
                        "open" === e.data.type ? o(e.data.args[0]) : "message" === e.data.type ? s(e.data.args[0]) : "close" === e.data.type ? c(e.data.args[0], e.data.args[1]) : "error" === e.data.type && i()
                    }
                    ,
                    r.sendMessage({
                        type: "websocket",
                        websocket: {
                            url: e.toString(),
                            protocols: t,
                            requestHeaders: a,
                            channel: this.channel.port2
                        }
                    }, [this.channel.port2])
                }
                send(...e) {
                    if (this.readyState === n.CONNECTING)
                        throw new DOMException("Failed to execute 'send' on 'WebSocket': Still in CONNECTING state.");
                    let t = e[0];
                    t.buffer && (t = t.buffer.slice(t.byteOffset, t.byteOffset + t.byteLength)),
                    s.call(this.channel.port1, {
                        type: "data",
                        data: t
                    }, t instanceof ArrayBuffer ? [t] : [])
                }
                close(e, t) {
                    s.call(this.channel.port1, {
                        type: "close",
                        closeCode: e,
                        closeReason: t
                    })
                }
            }
            function w(e, t, r) {
                console.error(`error while processing '${r}': `, t),
                e.postMessage({
                    type: "error",
                    error: t
                })
            }
            function f(e) {
                for (let t = 0; t < e.length; t++) {
                    const r = e[t];
                    if (!"!#$%&'*+-.0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ^_`abcdefghijklmnopqrstuvwxyz|~".includes(r))
                        return !1
                }
                return !0
            }
            const g = ["ws:", "wss:"]
              , y = [101, 204, 205, 304]
              , b = [301, 302, 303, 307, 308];
            class m {
                constructor(e) {
                    this.worker = new p(e)
                }
                createWebSocket(e, t=[], r, a) {
                    try {
                        e = new URL(e)
                    } catch (t) {
                        throw new DOMException(`Faiiled to construct 'WebSocket': The URL '${e}' is invalid.`)
                    }
                    if (!g.includes(e.protocol))
                        throw new DOMException(`Failed to construct 'WebSocket': The URL's scheme must be either 'ws' or 'wss'. '${e.protocol}' is not allowed.`);
                    Array.isArray(t) || (t = [t]),
                    t = t.map(String);
                    for (const e of t)
                        if (!f(e))
                            throw new DOMException(`Failed to construct 'WebSocket': The subprotocol '${e}' is invalid.`);
                    a = a || {};
                    return new u(e,t,this.worker,a)
                }
                async fetch(e, r) {
                    const a = new Request(e,r)
                      , o = r?.headers || a.headers
                      , s = o instanceof Headers ? Object.fromEntries(o) : o
                      , n = a.body;
                    let c = new URL(a.url);
                    if (c.protocol.startsWith("blob:")) {
                        const e = await t(c)
                          , r = new Response(e.body,e);
                        return r.rawHeaders = Object.fromEntries(e.headers),
                        r
                    }
                    for (let e = 0; ; e++) {
                        let t = (await this.worker.sendMessage({
                            type: "fetch",
                            fetch: {
                                remote: c.toString(),
                                method: a.method,
                                headers: s,
                                body: n || void 0
                            }
                        }, n ? [n] : [])).fetch
                          , o = new Response(y.includes(t.status) ? void 0 : t.body,{
                            headers: new Headers(t.headers),
                            status: t.status,
                            statusText: t.statusText
                        });
                        o.rawHeaders = t.headers,
                        o.rawResponse = t,
                        o.finalURL = c.toString();
                        const i = r?.redirect || a.redirect;
                        if (!b.includes(o.status))
                            return o;
                        switch (i) {
                        case "follow":
                            {
                                const t = o.headers.get("location");
                                if (20 > e && null !== t) {
                                    c = new URL(t,c);
                                    continue
                                }
                                throw new TypeError("Failed to fetch")
                            }
                        case "error":
                            throw new TypeError("Failed to fetch");
                        case "manual":
                            return o
                        }
                    }
                }
            }
            console.debug("bare-mux: running v2.1.7 (build c56d286)"),
            e.BareClient = m,
            e.BareMuxConnection = class {
                constructor(e) {
                    this.worker = new p(e)
                }
                async getTransport() {
                    return (await this.worker.sendMessage({
                        type: "get"
                    })).name
                }
                async setTransport(e, t, r) {
                    await this.setManualTransport(`\n\t\t\tconst { default: BareTransport } = await import("${e}");\n\t\t\treturn [BareTransport, "${e}"];\n\t\t`, t, r)
                }
                async setManualTransport(e, t, r) {
                    if ("bare-mux-remote" === e)
                        throw new Error("Use setRemoteTransport.");
                    await this.worker.sendMessage({
                        type: "set",
                        client: {
                            function: e,
                            args: t
                        }
                    }, r)
                }
                async setRemoteTransport(e, t) {
                    const r = new MessageChannel;
                    r.port1.onmessage = async t => {
                        const r = t.data.port
                          , a = t.data.message;
                        if ("fetch" === a.type)
                            try {
                                e.ready || await e.init(),
                                await async function(e, t, r) {
                                    const a = await r.request(new URL(e.fetch.remote), e.fetch.method, e.fetch.body, e.fetch.headers, null);
                                    if (!d() && a.body instanceof ReadableStream) {
                                        const e = new Response(a.body);
                                        a.body = await e.arrayBuffer()
                                    }
                                    a.body instanceof ReadableStream || a.body instanceof ArrayBuffer ? s.call(t, {
                                        type: "fetch",
                                        fetch: a
                                    }, [a.body]) : s.call(t, {
                                        type: "fetch",
                                        fetch: a
                                    })
                                }(a, r, e)
                            } catch (e) {
                                w(r, e, "fetch")
                            }
                        else if ("websocket" === a.type)
                            try {
                                e.ready || await e.init(),
                                await async function(e, t, r) {
                                    const [a,o] = r.connect(new URL(e.websocket.url), e.websocket.protocols, e.websocket.requestHeaders, (t => {
                                        s.call(e.websocket.channel, {
                                            type: "open",
                                            args: [t]
                                        })
                                    }
                                    ), (t => {
                                        t instanceof ArrayBuffer ? s.call(e.websocket.channel, {
                                            type: "message",
                                            args: [t]
                                        }, [t]) : s.call(e.websocket.channel, {
                                            type: "message",
                                            args: [t]
                                        })
                                    }
                                    ), ( (t, r) => {
                                        s.call(e.websocket.channel, {
                                            type: "close",
                                            args: [t, r]
                                        })
                                    }
                                    ), (t => {
                                        s.call(e.websocket.channel, {
                                            type: "error",
                                            args: [t]
                                        })
                                    }
                                    ));
                                    e.websocket.channel.onmessage = e => {
                                        "data" === e.data.type ? a(e.data.data) : "close" === e.data.type && o(e.data.closeCode, e.data.closeReason)
                                    }
                                    ,
                                    s.call(t, {
                                        type: "websocket"
                                    })
                                }(a, r, e)
                            } catch (e) {
                                w(r, e, "websocket")
                            }
                    }
                    ,
                    await this.worker.sendMessage({
                        type: "set",
                        client: {
                            function: "bare-mux-remote",
                            args: [r.port2, t]
                        }
                    }, [r.port2])
                }
                getInnerPort() {
                    return this.worker.port
                }
            }
            ,
            e.BareWebSocket = u,
            e.WebSocketFields = n,
            e.WorkerConnection = p,
            e.browserSupportsTransferringStreams = d,
            e.default = m,
            e.maxRedirects = 20,
            e.validProtocol = f,
            Object.defineProperty(e, "__esModule", {
                value: !0
            })
        }
        ));
    </script>
</head>
<body>
    <div class="container">
        <header class="header">
            <h1>üöÄ Scramjet-Style Proxy</h1>
            <p class="subtitle">Using actual Scramjet proxy architecture</p>
        </header>

        <div class="controls">
            <div class="url-input-group">
                <input type="text" 
                       id="url-input" 
                       class="url-input" 
                       placeholder="https://orteil.dashnet.org/cookieclicker/"
                       value="https://orteil.dashnet.org/cookieclicker/">
                <button id="load-btn" class="load-btn">
                    üîÑ Load via Scramjet
                </button>
            </div>
            
            <div class="preset-buttons">
                <button class="preset-btn" data-url="https://orteil.dashnet.org/cookieclicker/">
                    üç™ Cookie Clicker
                </button>
                <button class="preset-btn" data-url="https://www.google.com">
                    üîç Google
                </button>
                <button class="preset-btn" data-url="https://www.youtube.com">
                    ‚ñ∂Ô∏è YouTube
                </button>
                <button class="preset-btn" data-url="https://github.com">
                    üíª GitHub
                </button>
            </div>
        </div>

        <div class="proxy-container">
            <div class="proxy-header">
                <div class="status-indicator">
                    <span class="status-label">Proxy:</span>
                    <span id="proxy-status" class="status-value">Initializing...</span>
                </div>
                <div class="proxy-controls">
                    <button id="reload-btn" class="control-btn" title="Reload">
                        üîÑ
                    </button>
                    <button id="devtools-btn" class="control-btn" title="DevTools">
                        üîß
                    </button>
                </div>
            </div>

            <div class="proxy-content">
                <div class="loading-overlay" id="loading">
                    <div class="spinner"></div>
                    <p id="loading-text">Initializing Scramjet proxy...</p>
                </div>
                <div class="error-overlay" id="error" style="display: none;">
                    <div class="error-icon">‚ö†Ô∏è</div>
                    <h3>Proxy Error</h3>
                    <p id="error-message"></p>
                    <button id="retry-btn" class="retry-btn">Retry</button>
                    <button id="simple-proxy-btn" class="direct-btn">Use Simple Proxy</button>
                </div>
                <iframe id="proxy-frame" 
                        sandbox="allow-scripts allow-same-origin allow-forms allow-popups allow-modals"
                        class="proxy-frame"></iframe>
            </div>

            <div class="proxy-info">
                <div class="info-item">
                    <span>Mode:</span>
                    <span id="proxy-mode">Scramjet Proxy</span>
                </div>
                <div class="info-item">
                    <span>Transport:</span>
                    <span id="transport-status">Setting up...</span>
                </div>
                <div class="info-item">
                    <span>Loaded:</span>
                    <span id="load-time">-</span>
                </div>
            </div>
        </div>

        <div class="debug-panel">
            <h3>Debug Info</h3>
            <div class="debug-logs" id="debug-logs">
                <div class="log-entry">Initializing proxy system...</div>
            </div>
        </div>

        <footer class="footer">
            <p>Based on Scramjet proxy architecture | Uses BareMux for transport</p>
            <p class="warning">‚ö†Ô∏è This is a technical demonstration. Some sites may not work.</p>
        </footer>
    </div>

    <script src="script.js"></script>
</body>
</html>
